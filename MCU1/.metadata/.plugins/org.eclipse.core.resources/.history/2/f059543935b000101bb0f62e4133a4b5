#include "stm32f446_uart_driver.h"

void USART_PeriClockControl(USART_RegDef_t *pUSARTx, uint8_t EnorDi)
{
    if(EnorDi == ENABLE) {
        if(pUSARTx == USART1) USART1_PCLK_EN();
        else if(pUSARTx == USART2) USART2_PCLK_EN();
        else if(pUSARTx == USART3) USART3_PCLK_EN();
        else if(pUSARTx == UART4) UART4_PCLK_EN();
        else if(pUSARTx == UART5) UART5_PCLK_EN();
        else if(pUSARTx == USART6) USART6_PCLK_EN();
    } else {
        if(pUSARTx == USART1) USART1_PCLK_DI();
        else if(pUSARTx == USART2) USART2_PCLK_DI();
        else if(pUSARTx == USART3) USART3_PCLK_DI();
        else if(pUSARTx == UART4) UART4_PCLK_DI();
        else if(pUSARTx == UART5) UART5_PCLK_DI();
        else if(pUSARTx == USART6) USART6_PCLK_DI();
    }
}

void USART_Init(USART_Handle_t *pUSARTHandle)
{
    // Habilitar clock
    USART_PeriClockControl(pUSARTHandle->pUSARTx, ENABLE);

    // Calcular BRR para 115200 baud @ 84MHz
    // BRR = 84000000 / (16 * 115200) = 45.5729
    // Mantisa = 45, Fraction = 0.5729 * 16 = 9.166 ≈ 9
    uint32_t temp_brr = ((45 << 4) | 9);
    pUSARTHandle->pUSARTx->BRR = temp_brr;

    // Configurar Control Register 1
    // UE = USART Enable, TE = Transmitter Enable, M = Word length (0=8bits)
    pUSARTHandle->pUSARTx->CR1 = (USART_CR1_UE | USART_CR1_TE);

    // Pequeño delay para estabilización
    for(volatile uint32_t i = 0; i < 1000; i++);
}
